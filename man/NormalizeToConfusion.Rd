% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NormalizeToConfusion.R
\name{NormalizeToConfusion}
\alias{NormalizeToConfusion}
\title{Normalize Input to a 2-Rater Confusion/Coincidence Matrix}
\usage{
NormalizeToConfusion(x, y = NULL, levels = NULL, useNA = "no")
}
\arguments{
\item{x}{Input object (see details).}

\item{y}{Optional second vector of ratings (used only if \code{x} is a single vector).}

\item{levels}{Optional vector of category levels to enforce (same order for rows/cols).
If \code{NULL}, levels are inferred from the union of observed categories.}

\item{useNA}{Passed to \code{table()} when building the contingency table
(e.g., \code{"no"}, \code{"ifany"}, \code{"always"}).}
}
\value{
A square numeric \code{matrix} with dimnames (rows = rater A levels, cols = rater B levels).
}
\description{
Accepts diverse inputs and returns a square contingency table (matrix)
for exactly two raters across \eqn{k} categories.
}
\details{
Supported inputs:
\itemize{
\item \strong{table} (2D): already a confusion table.
\item \strong{matrix} that looks like a confusion table
(square, non-negative, etc.).
\item \strong{matrix/data.frame} with 2 columns and >2 rows: interpreted as raw ratings
(subjects in rows, raters in columns).
\item \strong{list} of 2 vectors: each element is one rater's ratings.
\item \strong{two vectors} \code{x}, \code{y}: ratings of two raters.
}

If you have more than two raters, select the required pair before passing
the data to the function.
}
\examples{
A <- c("pos","neg","pos","inc")
B <- c("pos","pos","neg","inc")
NormalizeToConfusion(A, B)

tab <- table(A, B)
NormalizeToConfusion(tab)

set.seed(1)
C <- sample(c("pos","neg","inc"), length(A), TRUE)
df <- data.frame(R1=A, R2=B, R3=C)
NormalizeToConfusion(df[, 1:2])      # R1 vs R2
NormalizeToConfusion(df[, c(1,3)])   # R1 vs R3

# list of rating vectors:
NormalizeToConfusion(list(A, B))

# use NAs
B[2] <- NA
NormalizeToConfusion(A, B, useNA="always")

anxiety <- data.frame(
  rater1 = c(3,3,3,4,5,5,2),
  rater2 = c(3,6,4,6,2,4,2),
  rater3 = c(2,1,4,4,3,2,1)
)

x <- anxiety[, 1]
y <- anxiety[, 2]

# Two vectors:
NormalizeToConfusion(x, y)
# matrix/data.frame with 2 columns (subjects × raters):
NormalizeToConfusion(cbind(x, y))
NormalizeToConfusion(data.frame(x, y))
# list with 2 elements (same as vector interface):
NormalizeToConfusion(list(x, y))

# table:
ratingscale <- sort(unique(c(x, y)))
NormalizeToConfusion(table(factor(x, levels=ratingscale), 
                           factor(y, levels=ratingscale)))

d.anxiety <- data.frame(
  rater  = c("rater1", "rater1", "rater1", "rater1", "rater1", "rater1", "rater1", 
             "rater2", "rater2", "rater2", "rater2", "rater2", "rater2", "rater2", 
             "rater3", "rater3", "rater3", "rater3", "rater3", "rater3", "rater3"), 
  rating = c(3, 3, 3, 4, 5, 5, 2, 
             3, 6, 4, 6, 2, 4, 2, 
             2, 1, 4, 4, 3, 2, 1), 
  subj   = c(1, 2, 3, 4, 5, 6, 7, 
             1, 2, 3, 4, 5, 6, 7, 
             1, 2, 3, 4, 5, 6, 7)
)

# matrix/data.frame with 2 columns (subjects × raters):
NormalizeToConfusion(
  RaterFrame(rating ~ subj | rater, data=d.anxiety, 
             subset=rater \%in\% c("rater1","rater2"), incl.subj=FALSE)
)

}
\seealso{
\code{\link[=IsConfusionTable]{IsConfusionTable()}}, \code{\link[=RaterFrame]{RaterFrame()}}, \code{\link[=PairApply]{PairApply()}}
}
\keyword{internal}
